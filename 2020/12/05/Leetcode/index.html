<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="CreatorDP">





<title>Leetcode | DP&#39;s BLOG</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/js/APlayer.min.js"></script>
    
    <script src="/js/pjax.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">CreatorDP&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">CreatorDP&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Leetcode</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">CreatorDP</a>
                    

                    
                        <span class="post-time">
                        Created Date: <a href="#">December 5, 2020&nbsp;&nbsp;8:02:42</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Algorithm/">Algorithm</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="冷却时间-间隔保证"><a href="#冷却时间-间隔保证" class="headerlink" title="冷却时间/间隔保证"></a>冷却时间/间隔保证</h2><h4 id="入门1（求最少时间）"><a href="#入门1（求最少时间）" class="headerlink" title="入门1（求最少时间）"></a>入门1（求最少时间）</h4><h6 id="621任务调度器"><a href="#621任务调度器" class="headerlink" title="621任务调度器"></a>621任务调度器</h6><p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 最短时间 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/task-scheduler">https://leetcode-cn.com/problems/task-scheduler</a></p>
<h6 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h6><p>给定的数据表示，每一次使用一个字母，那么我们需要n时间的冷却。我们入手是需要一定的贪心算法。首先我们需要知道最大的一种任务数(max)。然后最少时间是在所有任务数(sum)和(max-1)*(n+1)+cnt。cnt代表有和我们的最大任务数相同的任务。</p>
<h4 id="入门2（求一个最少时间的例子）"><a href="#入门2（求一个最少时间的例子）" class="headerlink" title="入门2（求一个最少时间的例子）"></a>入门2（求一个最少时间的例子）</h4><h6 id="767重构字符串"><a href="#767重构字符串" class="headerlink" title="767重构字符串"></a>767重构字符串</h6><p>给定一个字符串<code>S</code>，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p>
<h6 id="解决思路1"><a href="#解决思路1" class="headerlink" title="解决思路1"></a>解决思路1</h6><p>使用大小堆，我们按一个字母出现的次数作为比较大小的依据，然后每次取出两个进行摆放，减去1之后如果为0那么我们就抛弃，如果不为零我们将其再次放入大小堆中。在实现之前我们是需要进行判断的，判断是否能够完成。这种字母判断非常简单，只要最大字母数小于或者等于总数一半即可。</p>
<h6 id="解决思路2"><a href="#解决思路2" class="headerlink" title="解决思路2"></a>解决思路2</h6><p>同样需要先判断是否能够完成。之后我们可以将最大出现的字母放在双数，然后再将其他字母进行填充（如果最大字母数没要超过最大数那么其他字母依然可以继续填充双数位，最后填充单数位。</p>
<h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><h6 id="358K距离间隔冲排字符串"><a href="#358K距离间隔冲排字符串" class="headerlink" title="358K距离间隔冲排字符串"></a>358K距离间隔冲排字符串</h6><p>给你一个非空的字符串 s 和一个整数 k，你要将这个字符串中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离至少为 k。</p>
<p>所有输入的字符串都由小写字母组成，如果找不到距离至少为 k 的重排结果，请返回一个空字符串 “”。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rearrange-string-k-distance-apart">https://leetcode-cn.com/problems/rearrange-string-k-distance-apart</a></p>
<h6 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h6><p>我们这里需要先进行判断，可以使用入门1进行判断，那么我们如何得到一个例子呢？这里特别需要注意的入门2的思路2是不能使用的，因为可能会出现重复的可能，只能使用思路1的方式进行。</p>
<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><h6 id="剑指offer38"><a href="#剑指offer38" class="headerlink" title="剑指offer38"></a>剑指offer38</h6><p>输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>和排列相关的题目使用回溯比较好，因为刚好可以对应的每个分支的结果。</p>
<p>这里注意我们题目给出的东西可能出现重复，所以需要进行排除重复的处理，可以使用set进行排除，但是我们可以换一种遍历所有结果的方式，可以进行剪枝操作。</p>
<h2 id="贪心问题"><a href="#贪心问题" class="headerlink" title="贪心问题"></a>贪心问题</h2><blockquote>
<p>单调栈的本质是在有限的长度（你可以删除或者保留一定长度的情况下）来取得最大值或者最小值</p>
</blockquote>
<h4 id="数字变换入门1-递增最大小于N"><a href="#数字变换入门1-递增最大小于N" class="headerlink" title="数字变换入门1 递增最大小于N"></a>数字变换入门1 递增最大小于N</h4><h6 id="738-Monotone-Increasing-Digits"><a href="#738-Monotone-Increasing-Digits" class="headerlink" title="738. Monotone Increasing Digits"></a>738. Monotone Increasing Digits</h6><p>Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.</p>
<p>(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x &lt;= y.)</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/monotone-increasing-digits">https://leetcode-cn.com/problems/monotone-increasing-digits</a></p>
<h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><p>我们这里需要最大，但是不大于N。那么我们需高位越大越好，那么最好的情况就是等于N。但是这里我们需要从高到低需要变大，那么我们在某一位不能满足的时候我们就比该位小于1，后面我们就可以取999了。那么我们什么时候可以取呢？——当该位后面不和自己的一位相等next比较（除非一直到最后一位都一样），如果该位大于next那么我们这一位就需要-1后面取9，如果小于等于next那么我们就可以取自己这位最大值。</p>
<h4 id="数字变换入门2-删除k位取最小值"><a href="#数字变换入门2-删除k位取最小值" class="headerlink" title="数字变换入门2 删除k位取最小值"></a>数字变换入门2 删除k位取最小值</h4><h6 id="402-Remove-K-Digits"><a href="#402-Remove-K-Digits" class="headerlink" title="402. Remove K Digits"></a>402. Remove K Digits</h6><p>Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.</p>
<p>Note:<br>The length of num is less than 10002 and will be ≥ k.<br>The given num does not contain any leading zero.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-k-digits">https://leetcode-cn.com/problems/remove-k-digits</a></p>
<h4 id="数字变换提升1-删除重复元素"><a href="#数字变换提升1-删除重复元素" class="headerlink" title="数字变换提升1 删除重复元素"></a>数字变换提升1 删除重复元素</h4><h6 id="316-Remove-Duplicate-Letters"><a href="#316-Remove-Duplicate-Letters" class="headerlink" title="316. Remove Duplicate Letters"></a>316. Remove Duplicate Letters</h6><p>Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicate-letters">https://leetcode-cn.com/problems/remove-duplicate-letters</a></p>
<h6 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h6><p>我们这里需要变通一下，因为不再是删除任意个k字符，只能删除重复元素。我们同样使用单调栈来处理，只是这一次我们要判断该字符能不能删除才能进行删除操作。如果最后还剩多余的K，我们直接从前往后删除对应字符。最后需要注意的是我们不能让重复出现的字符再次放入字符串中。</p>
<h4 id="数字变换提升2-从两个里面获取k个元素"><a href="#数字变换提升2-从两个里面获取k个元素" class="headerlink" title="数字变换提升2 从两个里面获取k个元素"></a>数字变换提升2 从两个里面获取k个元素</h4><h6 id="321-Create-Maximum-Number"><a href="#321-Create-Maximum-Number" class="headerlink" title="321. Create Maximum Number"></a>321. Create Maximum Number</h6><p>Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k &lt;= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits.</p>
<p>Note: You should try to optimize your time and space complexity.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/create-maximum-numbe">https://leetcode-cn.com/problems/create-maximum-numbe</a></p>
<h6 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h6><p>只能暴力枚举K个数字在每个数字取x(x&lt;K)的情况。</p>
<h6 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h6><p>使用单调队列来处理。但是 一定要注意到三种情况：1.我们的k已经用完了，后面的不能再保持单调了；2. 我们的k到最后也没有用完，其实我们可以直接在获取结果的时候减去对应的长度；3.恰好用完，这种情况无需进一步的操作。</p>
<h4 id="区间入门1（合并）"><a href="#区间入门1（合并）" class="headerlink" title="区间入门1（合并）"></a>区间入门1（合并）</h4><h6 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h6><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<h6 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h6><p>典型的贪心问题，但是需要注意这种区间贪心问题需要考虑到底对开始还是结束进行排序。我们需要得到所有的合并区间，我们不能按照结束点进行排序，因为你不知道从哪一个开始！！！！</p>
<h4 id="区间入门2（不相交）"><a href="#区间入门2（不相交）" class="headerlink" title="区间入门2（不相交）"></a>区间入门2（不相交）</h4><h6 id="252-会议室"><a href="#252-会议室" class="headerlink" title="252. 会议室"></a>252. 会议室</h6><p>给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，请你判断一个人是否能够参加这里面的全部会议。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/meeting-rooms">https://leetcode-cn.com/problems/meeting-rooms</a></p>
<h6 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h6><p>仍然是一个贪心问题，这里我们只是做一个判断，而不是计算出区间，所以我们可以直接对起点进行排序然后，然后再开一个list数组保存改组最后一个时间终点。这道题我们还可以使用终点进行排序，然后再判断。</p>
<h4 id="区间入门3（不相交个数）"><a href="#区间入门3（不相交个数）" class="headerlink" title="区间入门3（不相交个数）"></a>区间入门3（不相交个数）</h4><h6 id="acwing-908-最大不相交区间数量"><a href="#acwing-908-最大不相交区间数量" class="headerlink" title="acwing 908 最大不相交区间数量"></a>acwing 908 最大不相交区间数量</h6><p>给定N个闭区间[ai,biai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p>
<p>输出可选取区间的最大数量。</p>
<h6 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h6><p>终点排序，然后进行判断。这里不能使用起点进行排序，是因为可能起点最小但是终点最大，这样子我们无法求得最大不相交区间数量了。</p>
<h4 id="区间入门4（区间分组）"><a href="#区间入门4（区间分组）" class="headerlink" title="区间入门4（区间分组）"></a>区间入门4（区间分组）</h4><h6 id="acwing-906-区间分组"><a href="#acwing-906-区间分组" class="headerlink" title="acwing 906. 区间分组"></a>acwing 906. 区间分组</h6><p>给定N个闭区间[ai,biai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p>
<p>输出最小组数。</p>
<h6 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h6><p>对起点进行排序，然后选出能够满足的一个数组放入即可。</p>
<h4 id="区间入门5-（区间选点）"><a href="#区间入门5-（区间选点）" class="headerlink" title="区间入门5 （区间选点）"></a>区间入门5 （区间选点）</h4><h6 id="acwing-905-区间选点"><a href="#acwing-905-区间选点" class="headerlink" title="acwing 905. 区间选点"></a>acwing 905. 区间选点</h6><p>给定N个闭区间[ai,biai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</p>
<p>输出选择的点的最小数量。</p>
<p>位于区间端点上的点也算作区间内。</p>
<h6 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h6><p>我们按照终点进行排序，然后选择每一位的终点作为选点，如果后面的区间和该区间有重叠的部分我就不取新的终点；如果没有重叠的部分我们就选择新的终点作为选点。</p>
<h4 id="区间提升1（覆盖指定区间）"><a href="#区间提升1（覆盖指定区间）" class="headerlink" title="区间提升1（覆盖指定区间）"></a>区间提升1（覆盖指定区间）</h4><h6 id="acwing-907-区间覆盖"><a href="#acwing-907-区间覆盖" class="headerlink" title="acwing 907. 区间覆盖"></a>acwing 907. 区间覆盖</h6><h4 id="跳跃台阶"><a href="#跳跃台阶" class="headerlink" title="跳跃台阶"></a>跳跃台阶</h4><h6 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h6><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<h6 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h6><p>记录能够到达的最大值即可。如果某一个位置超过了能够到达的最大值，那么我们就无法继续前进了。</p>
<h4 id="选址"><a href="#选址" class="headerlink" title="选址"></a>选址</h4><h6 id="acwing"><a href="#acwing" class="headerlink" title="acwing"></a>acwing</h6><h4 id="最小平均等待时间——huffman树"><a href="#最小平均等待时间——huffman树" class="headerlink" title="最小平均等待时间——huffman树"></a>最小平均等待时间——huffman树</h4><h2 id="自动状态机"><a href="#自动状态机" class="headerlink" title="自动状态机"></a>自动状态机</h2><h4 id="入门1"><a href="#入门1" class="headerlink" title="入门1"></a>入门1</h4><h6 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a>剑指 Offer 20. 表示数值的字符串</h6><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof</a></p>
<h6 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h6><p>其实一开是我的思路是进行拆分，将数字都拆分成整数，然后我们再写一个整数的判断，但是这样写的细节太多了，我要分很多情况。这里可以引入一个自动状态机来解决这种匹配问题。</p>
<blockquote>
<p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：</p>
<p>有一个特殊的状态，被称作「初始状态」。<br>还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。<br>起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/</a></p>
</blockquote>
<p>我们使用有限状态自动机，需要确定几个预备条件：</p>
<ul>
<li><p>所有字符</p>
<p>  空格 「 」、数字「 0—9 」 、正负号 「 +-」 、小数点 「 . 」 、幂符号 「 eE 」</p>
</li>
<li><p>状态定义</p>
<ol start="0">
<li>开始的空格</li>
<li>幂符号前的正负号</li>
<li>小数点前的数字</li>
<li>小数点、小数点后的数字</li>
<li>当小数点前为空格时，小数点、小数点后的数字</li>
<li>幂符号</li>
<li>幂符号后的正负号</li>
<li>幂符号后的数字</li>
<li>结尾的空格</li>
</ol>
</li>
<li><p>结束状态</p>
<p>  合法的结束状态有 2, 3, 7, 8 。</p>
<p>  <img src="https://pic.leetcode-cn.com/6f41d7e46fd0344c013980e3f46429dd7a7311bb4292783a482466a90f15747b-Picture1.png" alt="Picture1.png"></p>
</li>
</ul>
<p>有些时候同一个符号会因为所处状态的不同，那么它能转移的状态也就不同了。</p>
<h2 id="字符串相等转换（转换为同类）"><a href="#字符串相等转换（转换为同类）" class="headerlink" title="字符串相等转换（转换为同类）"></a>字符串相等转换（转换为同类）</h2><p>字符串相等有很多的定义，最常见的是两个字符串完全相同；其次是只有包含的字符数目都相同即可；还有字符相对位置相同（但是字符可以不同）也可以。</p>
<h4 id="group入门1（字符数目相等"><a href="#group入门1（字符数目相等" class="headerlink" title="group入门1（字符数目相等)"></a>group入门1（字符数目相等)</h4><h6 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h6><p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p>
<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams">https://leetcode-cn.com/problems/group-anagrams</a></p>
<h6 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h6><p>我们可以将每一个String转换为char[]数组之后，然后使用Arrays.sort进行排序。这时候我们就可以快速进行判断。</p>
<h6 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h6><p>我们可以将String 进行字母数目统计，然后我们再按照顺序进行获得新的字符串。</p>
<h6 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h6><p>如果只有一个字符的差别，我们甚至可以比较字符相加之后求差值。然后如果两个数组中只有一个是多出来的，那么我们可以使用异或来求得答案。</p>
<h4 id="group入门2-（字符相对位置）"><a href="#group入门2-（字符相对位置）" class="headerlink" title="group入门2 （字符相对位置）"></a>group入门2 （字符相对位置）</h4><h6 id="249-Group-Shifted-Strings"><a href="#249-Group-Shifted-Strings" class="headerlink" title="249. Group Shifted Strings"></a>249. Group Shifted Strings</h6><p>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:</p>
<p>“abc” -&gt; “bcd” -&gt; … -&gt; “xyz”<br>Given a list of non-empty strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-shifted-strings">https://leetcode-cn.com/problems/group-shifted-strings</a></p>
<h6 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h6><p>我们可以将转移String的第0个位置变成a，其他的位置也减去相同的大小（我们需要进行26位的大小转换。）</p>
<h4 id="识别是否有—提升1（字符数目相等）"><a href="#识别是否有—提升1（字符数目相等）" class="headerlink" title="识别是否有—提升1（字符数目相等）"></a>识别是否有—提升1（字符数目相等）</h4><h6 id="567-Permutation-in-String"><a href="#567-Permutation-in-String" class="headerlink" title="567. Permutation in String"></a>567. Permutation in String</h6><p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string">https://leetcode-cn.com/problems/permutation-in-string</a></p>
<h6 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h6><p>我们需要找到字符数目相同的子字符串即可，但是我们使用排序的方式来用equals比较很是繁琐，而且无法利用前面的信息。我们这里直接存储j-i的所有我们想要的字符的个数，然后如果最终达到要求，我们再逐步减去前面的字符来达到我们长度的要求。（这里仍然是使用的数量比较的方式）。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h4 id="入门1（异或的妙用）"><a href="#入门1（异或的妙用）" class="headerlink" title="入门1（异或的妙用）"></a>入门1（异或的妙用）</h4><h6 id="389-Find-the-Difference"><a href="#389-Find-the-Difference" class="headerlink" title="389 Find the Difference"></a>389 Find the Difference</h6><p>You are given two strings s and t.</p>
<p>String t is generated by random shuffling string s and then add one more letter at a random position.</p>
<p>Return the letter that was added to t</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-difference">https://leetcode-cn.com/problems/find-the-difference</a></p>
<h6 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h6><p>常规的思路就是hashmap，但是这里我们可以使用异或求出多出来字符。</p>
<h6 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h6><p>Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.</p>
<p>Follow up: Could you implement a solution with a linear runtime complexity and without using extra memory?</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number">https://leetcode-cn.com/problems/single-number</a></p>
<h6 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h6><p>仍然和上题一样，可以使用异或来求得最终的答案。</p>
<h4 id="入门2"><a href="#入门2" class="headerlink" title="入门2"></a>入门2</h4><h6 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h6><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<h6 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h6><h4 id="提升1-（逻辑运算）"><a href="#提升1-（逻辑运算）" class="headerlink" title="提升1 （逻辑运算）"></a>提升1 （逻辑运算）</h4><h6 id="137-Single-Number-II"><a href="#137-Single-Number-II" class="headerlink" title="137. Single Number II"></a>137. Single Number II</h6><p>Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-ii">https://leetcode-cn.com/problems/single-number-ii</a></p>
<h6 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h6><p>我们想着如果也有类似于异或的方式来求得这个不同的数的话，那么我们解答方式就非常简单了。但是这里并没有这种运算符号，所以我们需要自己构建一个。每个数字的每一位（二进制表示）都需要进行以下的操作。</p>
<p><img src="https://dpassests.oss-cn-shanghai.aliyuncs.com/%E8%87%AA%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA.PNG"></p>
<p>因为这里状态有3个，所以我们至少需要两位二进制数字才能表示所有数字。所以我需要one和two两个数字。但是我们在这里暂时只关注一位的变化（因为其他位的变化也一样）。这里需要复习一下逻辑运算的公式和定律。</p>
<p><img src="https://dpassests.oss-cn-shanghai.aliyuncs.com/image-20201218123744730.png" alt="image-20201218123744730"></p>
<p><img src="https://dpassests.oss-cn-shanghai.aliyuncs.com/image-20201218125807085.png" alt="image-20201218125807085"></p>
<p>逻辑运算中+代表并，*代表交。</p>
<p>逻辑运算计算出真值表的步骤：</p>
<ol>
<li>查找出所有等于1的一行，写出对应的式子（全部使用*连接）</li>
<li>通过逻辑运算定理推出最终的答案。（不同的式子之间使用+连接）</li>
</ol>
<p>设当前状态为XY，输入为Z，那么我们可以分别为X和Y列出真值表</p>
<h4 id="提升2（如何分离两个数）"><a href="#提升2（如何分离两个数）" class="headerlink" title="提升2（如何分离两个数）"></a>提升2（如何分离两个数）</h4><h6 id="260-Single-Number-III"><a href="#260-Single-Number-III" class="headerlink" title="260. Single Number III"></a>260. Single Number III</h6><p>Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.</p>
<p>Follow up: Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-iii">https://leetcode-cn.com/problems/single-number-iii</a></p>
<h6 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h6><p>我们可以使用异或来得到两个只出现一次的数字。我们得到的结果是两个不同的数字的一个异或结果，我们取得x&amp;-x可以得到两个数的差值，然后我们再利用这一位得到对应其中的一个数，最后我们使用这个数异或得到另一个数字。</p>
<h2 id="原地旋转跳跃"><a href="#原地旋转跳跃" class="headerlink" title="原地旋转跳跃"></a>原地旋转跳跃</h2><p>对于我们程序员来说，翻转往往比旋转来得更容易一些（而且不需要额外的空间），所以对于旋转的题目，尽量转换成翻转。有时候如果数组中如果出现了数组长度和数组内数字大小有关，我们也可以采用这种方式。</p>
<h4 id="入门1（90度）"><a href="#入门1（90度）" class="headerlink" title="入门1（90度）"></a>入门1（90度）</h4><h6 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a>Rotate Image</h6><p>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).</p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image">https://leetcode-cn.com/problems/rotate-image</a></p>
<h6 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h6><p>先以对角线为轴进行翻转，再对每一行以中点进行翻转；我们可以拓展一下，如果需要我们旋转180度的话，我们就可以以直接对着两条中线进行翻转；如果我们要旋转270度的话，我们可以对应着另一条对角线进行翻转然后对中点进行翻转。</p>
<p>小技巧：</p>
<ol>
<li>左上到右下的对角线交换(i,j)与(j,i)</li>
<li>右上到左下的对角线交换(i,j)与(n-j-1, n-i-1)</li>
</ol>
<h4 id="入门2（前k个字符移动到末尾）"><a href="#入门2（前k个字符移动到末尾）" class="headerlink" title="入门2（前k个字符移动到末尾）"></a>入门2（前k个字符移动到末尾）</h4><h6 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h6><p>给定一个长度为 n 的一维数组，将前 k 个数移动到末尾。要求 <strong>原地</strong> 操作，该如何实现？</p>
<h6 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h6><p>我们可以将前k个部分进行翻转，然后再对剩余部分进行翻转，最后再对整个数组进行翻转。</p>
<h4 id="入门3-（如何查找出有重复的数字）"><a href="#入门3-（如何查找出有重复的数字）" class="headerlink" title="入门3 （如何查找出有重复的数字）"></a>入门3 （如何查找出有重复的数字）</h4><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h4 id="入门1（链表倒数第K个数字）"><a href="#入门1（链表倒数第K个数字）" class="headerlink" title="入门1（链表倒数第K个数字）"></a>入门1（链表倒数第K个数字）</h4><h6 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h6><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p>
<h6 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h6><p>第一次的思路肯定是比较普通的，先遍历链表得到链表的长度，然后再到达第(n-k)的位置即是我们所求的答案；那么我们有没有只遍历一次的方法呢？有的，那就是我们大名鼎鼎的双指针算法了。快指针先走K步，然后快慢指针一起前进，快指针到达终点。</p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><h4 id="入门1-层次遍历"><a href="#入门1-层次遍历" class="headerlink" title="入门1 层次遍历"></a>入门1 层次遍历</h4><h4 id="入门2-N叉树的层次遍历"><a href="#入门2-N叉树的层次遍历" class="headerlink" title="入门2 N叉树的层次遍历"></a>入门2 N叉树的层次遍历</h4><p>我们这一题主要时要熟悉一下Iterator</p>
<h2 id="高低变化"><a href="#高低变化" class="headerlink" title="高低变化"></a>高低变化</h2><blockquote>
<p>单调栈还可以维护左右较高或者较低，然后记录两者相隔大小，并且进行计算。</p>
</blockquote>
<h4 id="提高1两大夹一小"><a href="#提高1两大夹一小" class="headerlink" title="提高1两大夹一小"></a>提高1两大夹一小</h4><h6 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h6><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<h6 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1"></a>思路1</h6><p>我们先横着算，横着算需要的是该高度最长能够延伸多长。适合使用单调栈，记录横坐标，并且是按照其高度进行排列。</p>
<h6 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2"></a>思路2</h6><p>竖着算，我们需要求得该柱子左右两侧的最大值，并且取较小的一个作为其补偿的高度。</p>
<h4 id="提高2-两小夹一大"><a href="#提高2-两小夹一大" class="headerlink" title="提高2 两小夹一大"></a>提高2 两小夹一大</h4><h6 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h6><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h6 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h6><p>这里的思路可以借鉴提高1来实现，我们计算连续的面积，就是两小夹一大。因为如果我们后面迎来的是比当前柱子更小，我们前面已经是比该柱子小的了，那么这个柱子的面积最大扩展已经到头了。</p>
<h4 id="提高3"><a href="#提高3" class="headerlink" title="提高3"></a>提高3</h4><h6 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h6><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy">https://leetcode-cn.com/problems/candy</a></p>
<h6 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h6><p>因为要求高分必须比周围低分得到的糖果数要多，那么我们其实是求得从左到右和从右到左的连续递增较大的一个。</p>
<h4 id="终极1"><a href="#终极1" class="headerlink" title="终极1"></a>终极1</h4><h6 id="407-接雨水-II"><a href="#407-接雨水-II" class="headerlink" title="407. 接雨水 II"></a>407. 接雨水 II</h6><p>给你一个 <code>m x n</code> 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>
<h6 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h6><p>这里的思路是将整个模块分成内外，所以我们先将外围一圈全部添加进来（使用优先队列）；然后再获取外部最小值，探索其周围的柱子，如果比自己低那么将高度差添加到ans（然后再次添加到队列，高度取较大的），比自己高，那么就不会添加雨水，只改变添加的高度；我们需要一个st数组来保存已被遍历的柱子。</p>
<h4 id="终极2"><a href="#终极2" class="headerlink" title="终极2"></a>终极2</h4><h6 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a>85. 最大矩形</h6><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>
<h6 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h6><p>我们可以累积一列的高度，但是对于中间有0的列就会清空为0.得到这样一个row数组，我们可以将其转换为最大连续面积问题。</p>
<h2 id="不一样的DP"><a href="#不一样的DP" class="headerlink" title="不一样的DP"></a>不一样的DP</h2><h4 id="入门1-连续方格"><a href="#入门1-连续方格" class="headerlink" title="入门1 连续方格"></a>入门1 连续方格</h4><p>这题让我想起了状态DP，但是又和状态DP有区别，状态DP一般求的是方案数。这个是求某一个的最大连续格子。而且状态DP是指数级别的，这题明显不合适。</p>
<h6 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h6><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<h6 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h6><p>求周围的最小延伸边长，然后DP解决。</p>
<h2 id="需要一点数学"><a href="#需要一点数学" class="headerlink" title="需要一点数学"></a>需要一点数学</h2><h4 id="约瑟夫入门1"><a href="#约瑟夫入门1" class="headerlink" title="约瑟夫入门1"></a>约瑟夫入门1</h4><h6 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a>剑指 Offer 62. 圆圈中最后剩下的数字</h6><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</a></p>
<h6 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h6><p>公式：<code>f(N,M)=(f(N−1,M)+M)%N</code></p>
<p>可以很好理解；假设我们从最后一个幸存者开始反推，那么我们需要这个幸存者是最后一个，那么需要数一轮M，但是我们现在只有两个人那么我们就需要取模2；然后现在再加上一个人，那么我们的序号应该是什么样的？我们需要再数一轮M，但是现在是三个人我们就取模3；…</p>
<h4 id="补齐连续空间"><a href="#补齐连续空间" class="headerlink" title="补齐连续空间"></a>补齐连续空间</h4><h6 id="330-按要求补齐数组"><a href="#330-按要求补齐数组" class="headerlink" title="330. 按要求补齐数组"></a>330. 按要求补齐数组</h6><p>给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/patching-array">https://leetcode-cn.com/problems/patching-array</a></p>
<h6 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h6><p>补齐数组特点：</p>
<ul>
<li>假设数组 arr 添加一个元素即可覆盖 [1, n)内所有数字，那么添加的数字 m 一定满足m &lt;= n。</li>
<li>假设数组 arr 可以覆盖 [1, n) 的所有数字，则给 arr 内加元素 m ：<br>  若m &lt;= n，新数组可以覆盖[1, m + n) = [1, n) ∪ [m, m + n)内所有数字；</li>
</ul>
<h4 id="1-n有多少个1"><a href="#1-n有多少个1" class="headerlink" title="1-n有多少个1"></a>1-n有多少个1</h4><h6 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a>剑指 Offer 43. 1～n 整数中 1 出现的次数</h6><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof</a></p>
<h6 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h6><p>像这种9次方的数据量的时候，我们可以考虑将数字拆为每一位计算。</p>
<h4 id="如何使得乘积最大"><a href="#如何使得乘积最大" class="headerlink" title="如何使得乘积最大"></a>如何使得乘积最大</h4><h6 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a>剑指 Offer 14- I. 剪绳子</h6><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p>
<h6 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h6><p>看题目的时候觉得就是使用DP，而且n的大小刚好比较小，使用dp绰绰有余，但是题解中看到了数学解决方法觉得很有意思这里参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/solution/343-zheng-shu-chai-fen-tan-xin-by-jyd/%E3%80%82%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95%E5%9C%A8%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%86%85%E5%8D%B3%E5%8F%AF%E3%80%82">https://leetcode-cn.com/problems/integer-break/solution/343-zheng-shu-chai-fen-tan-xin-by-jyd/。数学方法在常数时间复杂度内即可。</a></p>
<h4 id="异或的小秘密"><a href="#异或的小秘密" class="headerlink" title="异或的小秘密"></a>异或的小秘密</h4><h6 id="5647-解码异或后的排列-双周赛44-t3"><a href="#5647-解码异或后的排列-双周赛44-t3" class="headerlink" title="5647. 解码异或后的排列 双周赛44 t3"></a>5647. 解码异或后的排列 双周赛44 t3</h6><p>给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。</p>
<p>它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。</p>
<p>给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-xored-permutation">https://leetcode-cn.com/problems/decode-xored-permutation</a></p>
<h6 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h6><p>＞︿＜啊啊啊为什么双周赛总是只能做2道题，啥时候能突破瓶颈。┭┮﹏┭┮</p>
<p>我们将奇数数位的异或值进行异或（从1开始），我们可以得到除了第一个数字的异或结果，然后我们将1-n异或结果和其异或得到第一个数字。最后的工作只有递推了。</p>
<h4 id="搭方块"><a href="#搭方块" class="headerlink" title="搭方块"></a>搭方块</h4><h4 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h4><p>杨辉三角其实是二项式展开。</p>
<h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><h4 id="入门1-序列化和反序列化二叉树"><a href="#入门1-序列化和反序列化二叉树" class="headerlink" title="入门1 序列化和反序列化二叉树"></a>入门1 序列化和反序列化二叉树</h4><h6 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a>剑指 Offer 37. 序列化二叉树</h6><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<h6 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h6><p>直接层次遍历进行序列化和反序列化。</p>
<h4 id="LRU-Least-Recently-Used"><a href="#LRU-Least-Recently-Used" class="headerlink" title="LRU(Least Recently Used)"></a>LRU(Least Recently Used)</h4><h6 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h6><ol>
<li>一个最大容量，get、put、size。</li>
<li>保证所有的操作都是O(1)复杂度</li>
<li>上次访问的元素在第一个</li>
</ol>
<h6 id="使用什么数据结构"><a href="#使用什么数据结构" class="headerlink" title="使用什么数据结构"></a>使用什么数据结构</h6><p>双向链表+哈希map</p>
<p><img src="https://dpassests.oss-cn-shanghai.aliyuncs.com/image-20201230232755459.png" alt="image-20201230232755459"></p>
<p>HashMap中存储的是key和指针。</p>
<ol>
<li>删除，删除队头元素。</li>
<li>更新，通过hashmap找到对应元素更新val，然后将该元素放置队尾。</li>
</ol>
<h4 id="LFU-Least-Frequently-Used"><a href="#LFU-Least-Frequently-Used" class="headerlink" title="LFU(Least Frequently Used)"></a>LFU(Least Frequently Used)</h4><p>这个算法设计和上面的不同在于我们需要保存一下每个节点被使用的次数。</p>
<h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><ol>
<li>删除时如何快速获得最小频率的节点，而且相同频率的节点要按照时间顺序排序。</li>
<li>如何快速找到对应节点。</li>
</ol>
<h6 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h6><ol>
<li>一个hashmap存储所有点key-node值——这样可以快速获取对应点</li>
<li>一个hashmap存储频率-list值——这样可以快速获取频率最小的链表，然后再删除头节点即可。</li>
<li>一个min和一个capacity来设置这个结构的大小。</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/9e1fd010642e306d4616e6580d0ac75ee4fd1ecca7a3351ae1be415c35d10f5a-01.png" alt="01.png"></p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p><img src="https://dpassests.oss-cn-shanghai.aliyuncs.com/image-20210125152148628.png" alt="image-20210125152148628"></p>
<p>Guava工具类已经有了对应数据结构，当然我们自己还可以设计一个。</p>
<h6 id="需要的结构和函数"><a href="#需要的结构和函数" class="headerlink" title="需要的结构和函数"></a>需要的结构和函数</h6><ol>
<li>bitset，这个数据结构底层是使用long数组来实现的，底层是需要判断到底是哪个long数字，然后再判断在这long的某个位置。</li>
<li>hash函数值计算，我们需要大的精确度就需要更多的hash函数，而且针对不同数据类型可以采用不同的策略，如果是ip这样唯一性的地址我们甚至可以直接开到2^32位大小（唯一的ip只需要一个hash函数就可以让准确率唯一）。</li>
</ol>
<h2 id="逆向思考"><a href="#逆向思考" class="headerlink" title="逆向思考"></a>逆向思考</h2><h4 id="并查集逆向合并"><a href="#并查集逆向合并" class="headerlink" title="并查集逆向合并"></a>并查集逆向合并</h4><h6 id="803-打砖块"><a href="#803-打砖块" class="headerlink" title="803 打砖块"></a>803 打砖块</h6><p>有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：</p>
<p>一块砖直接连接到网格的顶部，或者<br>至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时<br>给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。</p>
<p>返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。</p>
<p>注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bricks-falling-when-hit">https://leetcode-cn.com/problems/bricks-falling-when-hit</a></p>
<h6 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h6><p>当初思路就是判断是不是卡点（也就是该点将连通块一分为二的点，且分开后两个连通块，其中一块不能连通到顶部），但是这样动态维护始终没有想到比较好的方法。</p>
<p>看了题解之后，恍然大悟，并查集本身是将两个点合并在一起，那么这道题的逆向不就是合并吗。当我们将一个不稳定的连通块合并后变得稳定，那么该连通块的数量就是我们消除的额外砖块。</p>
<h4 id="DP无后效性"><a href="#DP无后效性" class="headerlink" title="DP无后效性"></a>DP无后效性</h4><h6 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a>174. 地下城游戏</h6><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dungeon-game">https://leetcode-cn.com/problems/dungeon-game</a></p>
<h6 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h6><p>对于这个东西，我们需要知道为什么我们正序来更新dp数组会失败，因为累计和会影响该路径后半部分的最小值。这样我们就无法使用DP了。</p>
<p>逆序为什么可以呢？因为逆序之后我们我们累计和无法影响路径前半部分最小值的变化。</p>
<h2 id="并查集的综和应用"><a href="#并查集的综和应用" class="headerlink" title="并查集的综和应用"></a>并查集的综和应用</h2><h4 id="移除同一连通块的方块"><a href="#移除同一连通块的方块" class="headerlink" title="移除同一连通块的方块"></a>移除同一连通块的方块</h4><h6 id="947-移除最多的同行或同列石头"><a href="#947-移除最多的同行或同列石头" class="headerlink" title="947. 移除最多的同行或同列石头"></a>947. 移除最多的同行或同列石头</h6><p>n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p>
<p>如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。</p>
<p>给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column">https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column</a></p>
<h6 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h6><p>理解题目意思比自己吭哧吭哧瞎写好很多，这个意思就是连通块最后只剩下一个，那么我们可以统计一下连通块的个数，然后用总个数减去连通块的个数。</p>
<p>那么如何改进并查集来实现连通块的统计呢？我们可以使用hashmap替代传统的数组，然后我们在root的时候检测一下是否有对应的键值对，没有的话需要cnt++，在union时cnt–。（因为hashmap没有提前初始化，在root的时候才会进行初始化）。</p>
<h4 id="存在多余的边（变成树）"><a href="#存在多余的边（变成树）" class="headerlink" title="存在多余的边（变成树）"></a>存在多余的边（变成树）</h4><h6 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a>684. 冗余连接</h6><p>在本问题中, 树指的是一个连通且无环的无向图。</p>
<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection">https://leetcode-cn.com/problems/redundant-connection</a></p>
<h6 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h6><p>树上多出了一条边，那么一定会形成一个三个点及三点以上的环，那么我们使用并查集，在发现添加一条边之前两个点就在一个连通块里面了，那么这条边是可以删除的。</p>
<h4 id="查找路径上最小的值"><a href="#查找路径上最小的值" class="headerlink" title="查找路径上最小的值"></a>查找路径上最小的值</h4><h6 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a>1631. 最小体力消耗路径</h6><p>你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。</p>
<p>一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。</p>
<p>请你返回从左上角走到右下角的最小 体力消耗值 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-with-minimum-effort">https://leetcode-cn.com/problems/path-with-minimum-effort</a></p>
<h6 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h6><p>这道题目也没有想到思路，真是羞愧。</p>
<p>参考思路：</p>
<ol>
<li>将边进行排序，然后再按照从小到大添加到并查集中，看是否起点和终点可以连通。</li>
<li>二分+DFS，二分在范围内进行查找，然后使用DFS进行判断是否可行</li>
</ol>
<h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><h4 id="分组拓扑"><a href="#分组拓扑" class="headerlink" title="分组拓扑"></a>分组拓扑</h4><h6 id="203-项目管理"><a href="#203-项目管理" class="headerlink" title="203. 项目管理"></a>203. 项目管理</h6><p>有 n 个项目，每个项目或者不属于任何小组，或者属于 m 个小组之一。group[i] 表示第 i 个小组所属的小组，如果第 i 个项目不属于任何小组，则 group[i] 等于 -1。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。</p>
<p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p>
<p>同一小组的项目，排序后在列表中彼此相邻。<br>项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。<br>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies">https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies</a></p>
<h6 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h6><p>在xxx之前或者说在xxx之后，我们可以迅速联想到拓扑序。这里有一个难点就是需要分组，每组需要连续，那么如何处理这样的拓扑序呢？其实我们可以进行组内外两次拓扑序，首先我们检测组外拓扑序是否成功，然后再进行组内拓扑序连接。</p>
<h2 id="神奇打印"><a href="#神奇打印" class="headerlink" title="神奇打印"></a>神奇打印</h2><h4 id="螺旋"><a href="#螺旋" class="headerlink" title="螺旋"></a>螺旋</h4><h6 id="59螺旋矩阵-II"><a href="#59螺旋矩阵-II" class="headerlink" title="59螺旋矩阵 II"></a>59螺旋矩阵 II</h6><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em>2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<h6 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h6><p>啊，这题完全想不到什么优雅的思路。参考一个高赞思路，代码太优雅了elegent!!!!!!直接上代码吧，太美了</p>
<pre><code class="java">class Solution &#123;
    public int[][] generateMatrix(int n) &#123;
        int tar = n*n;
        int l = 0, r = n-1, t=0, b= n-1;
        int [][] ans = new int [n][n];
        int num = 1;
        while(num&lt;=tar)&#123;
            for(int i=l;i&lt;=r;i++)ans[t][i] = num++;
            t++;
            for(int i=t;i&lt;=b;i++)ans[i][r] = num++;
            r--;
            for(int i=r;i&gt;=l;i--)ans[b][i] = num++;
            b--;
            for(int i=b;i&gt;=t;i--)ans[i][l] = num++;
            l++;
        &#125;
        return ans;
    &#125;
&#125;</code></pre>
<h6 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h6><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<h6 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h6><p>和上一个小题一样，但是要注意这个并不是一个正方形，所以需要在每次进行遍历都需要进行判断。</p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;
        int rows = matrix.length;
        int cols = matrix[0].length;
        int tar = rows*cols;
        int num = 0;
        int l=0,r=cols-1,t = 0, b=rows-1;
        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        while(num&lt;tar)&#123;
            for(int i=l;i&lt;=r;i++)&#123;
                list.add(matrix[t][i]);
                num++;
            &#125;
            if(num&gt;=tar)break;
            t++;
            for(int i=t;i&lt;=b;i++)&#123;
                list.add(matrix[i][r]);
                num++;
            &#125;
            if(num&gt;=tar)break;
            r--;
            for(int i=r;i&gt;=l;i--)&#123;
                list.add(matrix[b][i]);
                num++;
            &#125;
            if(num&gt;=tar)break;
            b--;
            for(int i=b;i&gt;=t;i--)&#123;
                list.add(matrix[i][l]);
                num++;
            &#125;
            if(num&gt;=tar)break;
            l++;
        &#125;
        return list;
    &#125;
&#125;</code></pre>
<h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><h4 id="入门1-只有正整数的加减乘除"><a href="#入门1-只有正整数的加减乘除" class="headerlink" title="入门1 只有正整数的加减乘除"></a>入门1 只有正整数的加减乘除</h4><h6 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a>227. 基本计算器 II</h6><p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p>
<p>字符串表达式仅包含非负整数，<code>+</code>， <code>-</code> ，<code>*</code>，<code>/</code> 四种运算符和空格 <code> </code>。 整数除法仅保留整数部分。</p>
<h6 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h6><p>我们这里直接将中缀表达式变成后缀表达式，然后按照后缀表达式的方法进行计算。</p>
<p>中缀—&gt;后缀（op stack保存符号；str保存中缀式子；因为数字是多位的，所以我们对每个个体后面添加一个空格方便分割）：</p>
<ol>
<li>c如果是数字的话直接放入str中</li>
<li>c如果是符号的话<ul>
<li>如果栈为空的话我们直接放入op中</li>
<li>如果栈顶符号优先级大于或等于c的话将栈顶弹出放入str中，直至栈空或者栈顶符号优先级小于c</li>
<li>如果栈顶符号优先级小于c的话直接将c放入op中</li>
</ul>
</li>
<li>c如果是(，直接放入op中</li>
<li>c如果是)，弹出op栈符号放入str中知道遇到(</li>
<li>最后我们需要检测op中是否还有符号，有符号的话我们就弹出放入str中直到op为空。</li>
</ol>
<p>后缀表达式计算（需要一个结果res栈）：</p>
<p>从左到右遍历，数字直接放在res栈中，如果是运算符的话：</p>
<ol>
<li>弹出两个数</li>
<li>计算后将结果push到res栈中</li>
<li>注意对于-和/我们弹出第二个数才是被减数和被除数。</li>
</ol>
<h6 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h6><p>如果我们希望能够计算带负整数的，最好式子中不要出现空格，否则很难处理。</p>
<h4 id="入门2-只有有负整数的加减计算"><a href="#入门2-只有有负整数的加减计算" class="headerlink" title="入门2 只有有负整数的加减计算"></a>入门2 只有有负整数的加减计算</h4><h6 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a>224. 基本计算器</h6><p>现一个基本的计算器来计算一个简单的字符串表达式 <code>s</code> 的值。</p>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= s.length &lt;= 3 * 105</code></p>
</li>
<li><p><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</p>
</li>
<li><p><code>s</code> 表示一个有效的表达式</p>
<h6 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h6></li>
</ul>
<p>这个题太垃圾了，表达式里面有啥放在最后的提示，真是醉了。这个题目只有加减和正负，那么我们就可以用一个符号栈ops记录要展开的符号变化，一个op表示当前符号。</p>
<ol>
<li>遇到(，我们需要保留当前op到ops来展开括号里面的符号</li>
<li>遇到)，我们需要去掉这个ops栈顶的展开符号。</li>
<li>遇到数字就不停累加</li>
<li>遇到空格就跳过</li>
<li>最后注意num还要加一次。</li>
</ol>
<pre><code class="java">class Solution &#123;
    public int calculate(String s) &#123;
        LinkedList&lt;Integer&gt; ops = new LinkedList&lt;&gt;();
        ops.push(1);
        int op = 1;
        int num = 0;
        int ans = 0;
        for(char c: s.toCharArray())&#123;
            if(c==&#39; &#39;)continue;
            if(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)&#123;
                num=num*10+(int)(c-&#39;0&#39;);
                continue;
            &#125;
            ans+=op*num;
            num = 0;
            if(c==&#39;-&#39;)&#123;
                op = -ops.peek();
            &#125;else if(c==&#39;+&#39;)op = ops.peek();
            else if(c==&#39;(&#39;)ops.push(op);
            else if(c==&#39;)&#39;)ops.pop();
        &#125;
        ans+=op*num;
        return ans;
    &#125;
&#125;</code></pre>
<h2 id="bfprt"><a href="#bfprt" class="headerlink" title="bfprt"></a>bfprt</h2><pre><code class="java">class Solution &#123;
    int a[],n;
    public int[] smallestK(int[] arr, int k) &#123;
        if(k==0)return new int[0];
        n = arr.length;
        a = new int[n+1];
        System.arraycopy(arr,0,a,1,n);
        bfprt(1,n,k);
        int [] ans = new int[k];
        for(int i=0;i&lt;k;i++)&#123;
            ans[i] = a[i+1];
        &#125;
        return ans;
    &#125;
    private int bfprt(int s, int e, int k)&#123;
        int pivot = getP(s,e);
        int index = partition(s,e,pivot);
        int num = index-s+1;
        if(num&gt;k)return bfprt(s,index-1,k);
        else if(num&lt;k)return bfprt(index+1,e,k-num);
        else return index;
    &#125;
    private int getP(int s, int e)&#123;
        if(e-s&lt;5)&#123;
            return getMidian(s,e);
        &#125;
        int subs = s-1;
        for(int i=s;i&lt;=e-4;i+=5)&#123;
            int idx = getMidian(i,i+4);
            swap(++subs,idx);
        &#125;
        return bfprt(s,subs,((subs-s+1)/2)+1);
    &#125;
    private void swap(int x, int y)&#123;
        int tmp = a[x];
        a[x] = a[y];
        a[y] = tmp;
    &#125;
    private int getMidian(int s, int e)&#123;
        for(int i=s+1;i&lt;=e;i++)&#123;
            for(int j=s;j&lt;i&amp;&amp;a[i]&lt;a[j];j++)swap(i,j);
        &#125;
        return (e-s)/2+s;
    &#125;
    private int partition(int s, int e, int pivot)&#123;
        swap(e,pivot);
        int idx = s;
        for(int i=s;i&lt;=e;i++)&#123;
            if(a[i]&lt;a[e])swap(idx++,i);
        &#125;
        swap(idx,e);
        return idx;
    &#125;
&#125;</code></pre>
<p>分析时间复杂度：我们需要使用到分治的主定理。</p>
<p>$$ T(n) = a*T(\frac{n}{b})+f(n)$$</p>
<p>$a\geq 1$代表每次到底要取多少块，$b&gt;1$代表每次要分成多少块，$f(n)$代表着每次需要的时间。令$c=\log_b{a},  0&lt;\sigma&lt;c, k\geq 0$：</p>
<p>$f(n) = O(n^{c-\sigma}), T(n) = \theta(n^c)$</p>
<p>$f(n) = O(n^{c}\log^k n), T(n) = \theta(n^c*\log^k n)$</p>
<p>$f(n) = \Omega(n^{c+\sigma}), T(n) = \Omega(f(n))$</p>
<p>有两个部分而且是嵌套的，第一个部分是bfprt整体，第二个部分是每次都需要找到pivot（也就是中位数）。最里层：</p>
<p>$T(n) = T(\frac{n}{5}) + 5*n, T(n) = \theta(n)$</p>
<p>因为相当于我们将数组分成5份，但是我们每次只取中位数组成的那一份，每5个排序就需要25的时间，但是只有$\frac{n}{5}$个那么$f(n)=5*n$</p>
<p>最后我们计算整体bfprt：</p>
<p>$T(n) = T(\frac n2)+\theta(n)$</p>
<p>我们每次都找到了中位数，然后分成两部分，但是只留下一部分继续操作，最后结果就是$\theta(n)$。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>CreatorDP</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://ammydan.github.io/2020/12/05/Leetcode/">https://ammydan.github.io/2020/12/05/Leetcode/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2020 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/12/16/%E6%8F%90%E9%AB%98%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2/">提高——搜索</a>
            
            
            <a class="next" rel="next" href="/2020/11/09/JAVA-Lambda%E6%9D%82%E8%AE%B0/">JAVA Lambda杂记</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© CreatorDP | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/nico.model.json"},"display":{"position":"right","width":250,"height":500,"hOffset":0,"vOffset":-20},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
<div id="player" style="z-index: 99999; float:right;">
</div>
</html>
