<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="CreatorDP">



    <meta name="description" content="净学了些精致的淘气o(*￣▽￣*)o">



<title>Angular | DP&#39;s BLOG</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">CreatorDP&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">CreatorDP&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Angular</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">CreatorDP</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 13, 2020&nbsp;&nbsp;23:39:39</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><img src="https://i.stack.imgur.com/ylFmG.png" alt="Angular&#39;s two way of binding"></p>
<p><img src="https://i.stack.imgur.com/4H7QJ.png" alt="React&#39;s one way binding"></p>
<h2 id="快速搭建环境"><a href="#快速搭建环境" class="headerlink" title="快速搭建环境"></a>快速搭建环境</h2><pre><code class="bash">npm install -g cnpm --registry=https://registry.npm.taobao.org
npm config set registry https://registry.npm.taobao.org 
npm config get registry </code></pre>
<p>安装Angular，我们在此使用的是npm来进行安装，所以在安装之前需要先安装好Node.JS并且设置好全局安装包的位置。做好准备工作之后再使用以下命令安装AngularJS</p>
<pre><code class="bash">npm install -g @angular/cli</code></pre>
<p>在想要创建angular项目的文件夹下输入以下命令</p>
<pre><code class="bashe">ng new &lt;my-app-project-name&gt;</code></pre>
<p>中间会询问一些配置信息，如果想要用默认配置，直接Enter键即可，创建项目需要一定的时间。</p>
<p>测试：运行应用，这里使用了一个AngularJS附带的web服务器来部署前端项目，可以使用以下命令启动服务器。</p>
<pre><code class="bash">ng serve --open</code></pre>
<p>我们在实际的过程中，是需要build项目得到对应的JS、CSS、HTML静态文件，然后根据需求既可以和后端代码部署在同一个服务器上，也可以前后端分离部署。</p>
<p>如果我们需要在项目中创建一个组件，那么我们可以使用以下命令</p>
<pre><code class="bash">ng g c &lt;componentname&gt;</code></pre>
<p>我们常常需要ng来下载东西，所以我们最好修改以下ng的下载源</p>
<pre><code class="bash">ng config cli.packageManager cnpm</code></pre>
<h4 id="配合安装和使用BootStrap4（ng-bootstrap"><a href="#配合安装和使用BootStrap4（ng-bootstrap" class="headerlink" title="配合安装和使用BootStrap4（ng-bootstrap)"></a>配合安装和使用BootStrap4（ng-bootstrap)</h4><p>在对应的项目文件夹下使用以下命令</p>
<pre><code class="bash">ng add @ng-bootstrap/ng-bootstrap</code></pre>
<h4 id="使用material"><a href="#使用material" class="headerlink" title="使用material"></a>使用material</h4><pre><code class="bash">ng add @angular/material</code></pre>
<h4 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h4><p>放弃本地修改</p>
<pre><code class="bash">git checkout .</code></pre>
<p>回退到某个版本</p>
<pre><code class="bash">git reset --hard &lt;checksum&gt;</code></pre>
<h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><p><img src="D:\frontEnd\ammydan.github.io\public\img\image-20201025020246091.png" alt="image-20201025020246091"></p>
<p>build code and manage your code。文件太多的时候，我们需要一个模式来管理我们逐渐膨胀的代码文件，否则我们很难维护这个前端项目。</p>
<p>使用：</p>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><pre><code class="bash">npm init</code></pre>
<p>这个过程会需要我们回答很多问题，我们都可以enter键表示默认选项，然后我们在这个文件夹下，我们得到了package.json文件。这个文件管理我们的依赖。</p>
<h6 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h6><pre><code class="bash">npm install webpack --save-dev</code></pre>
<p>–save-dev代表我们仅在开发阶段使用，并不会在生产环境中需要。</p>
<h6 id="写npm脚本"><a href="#写npm脚本" class="headerlink" title="写npm脚本"></a>写npm脚本</h6><p>这个给了webpack一个切入点。</p>
<p><img src="D:\frontEnd\ammydan.github.io\public\img\image-20201025014244525.png" alt="image-20201025014244525"></p>
<p>如果在最后加上一个 -p，表示生产环境，然后webpack会minify我们的代码</p>
<h6 id="给定一个依赖hint"><a href="#给定一个依赖hint" class="headerlink" title="给定一个依赖hint"></a>给定一个依赖hint</h6><p>在切入点需要导入依赖的js文件，被依赖的文件需要export对应文件的变量和class等等才行。</p>
<p><img src="D:\frontEnd\ammydan.github.io\public\img\image-20201025014652095.png" alt="image-20201025014652095"></p>
<p><img src="D:\frontEnd\ammydan.github.io\public\img\image-20201025014446582.png" alt="image-20201025014446582"></p>
<p>这是ES6特性，但是这仅仅是给webpack使用的，然后webpack会最终产生ES5代码。</p>
<h6 id="本地热部署"><a href="#本地热部署" class="headerlink" title="本地热部署"></a>本地热部署</h6><p>随者你的代码改变，webpack也不断重新打包，而且这个是存储在你的内存里面的而不是磁盘文件。模拟一个服务器。</p>
<pre><code class="bash">npm install --save-dev webpack-dev-server</code></pre>
<p><img src="D:\frontEnd\ammydan.github.io\public\img\image-20201025015317986.png" alt="image-20201025015317986"></p>
<p><img src="D:\frontEnd\ammydan.github.io\public\img\image-20201025020019633.png" alt="image-20201025020019633"></p>
<h6 id="webpack配置文件"><a href="#webpack配置文件" class="headerlink" title="webpack配置文件"></a>webpack配置文件</h6><p>webpack.config.js</p>
<h6 id="下载导入css所需的package"><a href="#下载导入css所需的package" class="headerlink" title="下载导入css所需的package"></a>下载导入css所需的package</h6><pre><code class="bash">npm install css-loader style-loader --save-dev</code></pre>
<p>css同样需要在JS文件下进行导入</p>
<p><img src="D:\frontEnd\ammydan.github.io\public\img\image-20201025024141591.png" alt="image-20201025024141591"></p>
<h6 id="这些包的作用"><a href="#这些包的作用" class="headerlink" title="这些包的作用"></a>这些包的作用</h6><ul>
<li>css-loader这个是用来理解js文件中导入的css文件的。</li>
<li>style-loader加载CSS代码到DOM中。</li>
</ul>
<p>注意webpack是反序进行加载loader</p>
<h6 id="常见的loader"><a href="#常见的loader" class="headerlink" title="常见的loader"></a>常见的loader</h6><ul>
<li>babel-loder将js转换为预期的语法规范代码</li>
<li>css-loader</li>
<li>style-loader</li>
<li>html-loader</li>
</ul>
<h6 id="使用plugin"><a href="#使用plugin" class="headerlink" title="使用plugin"></a>使用plugin</h6><p><img src="D:\frontEnd\ammydan.github.io\public\img\image-20201025025120807.png" alt="image-20201025025120807"></p>
<h4 id="常用词汇"><a href="#常用词汇" class="headerlink" title="常用词汇"></a>常用词汇</h4><h6 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h6><p>在原理图中，是指一个在文件树上运行的函数，用于以指定方式创建、删除或修改文件，并返回一个新的 <code>Tree</code> 对象。</p>
<h6 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h6><p>在 schematics 中，一个用 <code>Tree</code> 类表示的虚拟文件系统。 Schematic 规则以一个 <code>tree</code> 对象作为输入，对它们进行操作，并且返回一个新的 <code>tree</code> 对象。</p>
<h6 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h6><p>脚手架库会定义如何借助创建、修改、重构或移动文件和代码等操作来生成或转换某个项目。每个原理图定义了一些规则，以操作一个被称为文件树的虚拟文件系统。</p>
<h2 id="Angular-架构"><a href="#Angular-架构" class="headerlink" title="Angular 架构"></a>Angular 架构</h2><h4 id="Complier"><a href="#Complier" class="headerlink" title="Complier"></a>Complier</h4><p><img src="./image/image-20201108122612717.png" alt="image-20201108122612717"></p>
<h6 id="Program-Creation"><a href="#Program-Creation" class="headerlink" title="Program Creation"></a>Program Creation</h6><p> ~ is the process of TS discovering all of the source files it needs to understand your programmes.</p>
<ul>
<li>Starts with tsconfig.json.</li>
<li>It learns the imports of those and discovers more files(they might be in your app, they might be libraries that you imported from Node modules.)</li>
<li>Angular expands to set of .ts and .d.ts files to complie.(eg. ng factory files)</li>
</ul>
<h6 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h6><p>~ is taking the full set of files in your programmes and angular is looking through all of the classes in them and trying to find ones that are decorated with angular decorators.</p>
<ul>
<li>looking for Angular “things”</li>
<li>try to understand each component/ directive/etc in isolation</li>
<li>Gather information about the structure.</li>
</ul>
<h6 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h6><ul>
<li>Look at the whole program at once</li>
<li>Understatnd structure, dependencies</li>
<li>Make optimization decisions</li>
</ul>
<h6 id="Type-Checking"><a href="#Type-Checking" class="headerlink" title="Type Checking"></a>Type Checking</h6><ul>
<li>validate expressions in component templates</li>
<li>Done using code generation(“type check blocks”)</li>
</ul>
<h6 id="Emit-most-expensive"><a href="#Emit-most-expensive" class="headerlink" title="Emit (most expensive)"></a>Emit (most expensive)</h6><p>Generate ES5 which can run properly in browsers(Done by TS). And generate Angular code for each decorated class and “patch” it (Done by adding angular compiler).</p>
<h2 id="Angular工作区配置"><a href="#Angular工作区配置" class="headerlink" title="Angular工作区配置"></a>Angular工作区配置</h2><p>项目根目录下的angular.json提供了全工作区级的配置和具体项目的默认配置，供Angular CLI中的构建工具和开发工具使用。该文件中的路径都是相对于工作区根目录的。</p>
<table>
<thead>
<tr>
<th><code>app/app.component.spec.ts</code></th>
<th>为根组件 <code>AppComponent</code> 定义了一个单元测试。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>main.ts</code></th>
<th>应用的主要切入点。用 <a target="_blank" rel="noopener" href="https://angular.cn/guide/glossary#jit">JIT 编译器</a>编译应用，然后引导应用的根模块（AppModule）在浏览器中运行。你也可以在不改变任何代码的情况下改用 <a target="_blank" rel="noopener" href="https://angular.io/guide/aot-compiler">AOT 编译器</a>，只要在 CLI 的 <code>build</code> 和 <code>serve</code> 命令中加上 <code>--aot</code> 标志就可以了。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>angular.json</code></th>
<th>为工作区中的所有项目指定 CLI 的默认配置，包括 CLI 要用到的构建、启动开发服务器和测试工具的配置项</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h4><p>这个文件所在的目录预示着这个目录是TS项目的根目录。tsconfig.json通常设定了根目录和编译器参数。JS项目同样有自己的jsconfig.json文件。</p>
<p>tsconfig.app.json是对tsconfig.json的拓展选项。</p>
<h2 id="基本逻辑流程"><a href="#基本逻辑流程" class="headerlink" title="基本逻辑流程"></a>基本逻辑流程</h2><blockquote>
<p>Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。 Angular 本身就是用 TypeScript 写成的。</p>
</blockquote>
<p><img src="https://angular.cn/generated/images/guide/architecture/overview2.png" alt="overview"></p>
<p>Angular应用的架构依赖于一些基本的概念。最基本的组成块是NgModules，NgModules为组件提供了编译环境。NgModules将相关代码集成一组功能。一个Angular应用被定义为一组NgModules。一个应用至少有一个root module来引导应用加载，并且通常还有很多特性模块。</p>
<ul>
<li>组件定义<em>视图</em>。视图是一组可见的屏幕元素，Angular 可以根据你的程序逻辑和数据来选择和修改它们。 每个应用都至少有一个根组件。</li>
<li>组件使用<em>服务</em>。服务会提供那些与视图不直接相关的功能。服务提供者可以作为<em>依赖</em>被<em>注入</em>到组件中， 这能让你的代码更加模块化、更加可复用、更加高效。</li>
</ul>
<p>模块、组件和服务都是使用<em>装饰器</em>的类，这<em>装饰器</em>会标出它们的类型并提供元数据，以告知 Angular 该如何使用它们。</p>
<ul>
<li>组件类的元数据将组件类和一个用来定义视图的<em>模板</em>关联起来。 模板把普通的 HTML 和 Angular <em>指令</em>与<em>绑定标记（markup）</em>组合起来，这样 Angular 就可以在渲染 HTML 之前先修改这些 HTML。</li>
<li>服务类的元数据提供了一些信息，Angular 要用这些信息来让组件可以通过<em>依赖注入（DI）</em>使用该服务。</li>
</ul>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>Angular 定义了 <code>NgModule</code>，它和 JavaScript（ES2015） 的模块不同而且有一定的互补性。 NgModule 为一个组件集声明了编译的上下文环境，它专注于某个应用领域、某个工作流或一组紧密相关的能力。 NgModule 可以将其组件和一组相关代码（如服务）关联起来，形成功能单元。</p>
<p>每个 Angular 应用都有一个<em>根模块</em>，通常命名为 <code>AppModule</code>。根模块提供了用来启动应用的引导机制。 一个应用通常会包含很多特性模块。</p>
<p>像 JavaScript 模块一样，NgModule 也可以从其它 NgModule 中导入功能，并允许导出它们自己的功能供其它 NgModule 使用。 比如，要在你的应用中使用路由器（Router）服务，就要导入 <code>Router</code> 这个 NgModule。</p>
<p>把你的代码组织成一些清晰的特性模块，可以帮助管理复杂应用的开发工作并实现可复用性设计。 另外，这项技术还能让你获得<em>惰性加载</em>（也就是按需加载模块）的优点，以尽可能减小启动时需要加载的代码体积。</p>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>每个 Angular 应用都至少有一个组件，也就是<em>根组件</em>，它会把组件树和页面中的 DOM 连接起来。 每个组件都会定义一个类，其中包含应用的数据和逻辑，并与一个 HTML <em>模板</em>相关联，该模板定义了一个供目标环境下显示的视图。</p>
<p><code>@Component()</code> 装饰器表明紧随它的那个类是一个组件，并提供模板和该组件专属的元数据。</p>
<h4 id="工作区和项目文件结构"><a href="#工作区和项目文件结构" class="headerlink" title="工作区和项目文件结构"></a>工作区和项目文件结构</h4><p>你会以 Angular 工作空间作为上下文来开发应用。工作空间包含一个或多个项目的文件集。一个项目就是一组包含独立应用或可共享库的文件。</p>
<h6 id="工作区间配置文件"><a href="#工作区间配置文件" class="headerlink" title="工作区间配置文件"></a>工作区间配置文件</h6><p>每个工作空间中的所有项目共享同一个 CLI 配置环境。该工作空间的顶层包含着全工作空间级的配置文件、根应用的配置文件以及一些包含根应用的源文件和测试文件的子文件夹。</p>
<h4 id="模板、指令和数据绑定"><a href="#模板、指令和数据绑定" class="headerlink" title="模板、指令和数据绑定"></a>模板、指令和数据绑定</h4><p>模板会把 HTML 和 Angular 的标记（markup）组合起来，这些标记可以在 HTML 元素显示出来之前修改它们。 模板中的<em>指令</em>会提供程序逻辑，而<em>绑定标记</em>会把你应用中的数据和 DOM 连接在一起。 有两种类型的数据绑定：</p>
<ul>
<li><em>事件绑定</em>让你的应用可以通过更新应用的数据来响应目标环境下的用户输入。</li>
<li><em>属性绑定</em>让你将从应用数据中计算出来的值插入到 HTML 中。</li>
</ul>
<p>在视图显示出来之前，Angular 会先根据你的应用数据和逻辑来运行模板中的指令并解析绑定表达式，以修改 HTML 元素和 DOM。 Angular 支持<em>双向数据绑定</em>，这意味着 DOM 中发生的变化（比如用户的选择）同样可以反映回你的程序数据中。</p>
<h4 id="服务与依赖注入"><a href="#服务与依赖注入" class="headerlink" title="服务与依赖注入"></a>服务与依赖注入</h4><p>对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建<em>服务</em>类。 服务类的定义通常紧跟在 “@Injectable()” 装饰器之后。该装饰器提供的元数据可以让你的服务作为依赖<em>被注入到</em>客户组件中。</p>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>Angular 的 <code>Router</code> 模块提供了一个服务，它可以让你定义在应用的各个不同状态和视图层次结构之间导航时要使用的路径。 它的工作模型基于人们熟知的浏览器导航约定：</p>
<ul>
<li>在地址栏输入 URL，浏览器就会导航到相应的页面。</li>
<li>在页面中点击链接，浏览器就会导航到一个新页面。</li>
<li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li>
</ul>
<p>不过路由器会把类似 URL 的路径映射到视图而不是页面。 当用户执行一个动作时（比如点击链接），本应该在浏览器中加载一个新页面，但是路由器拦截了浏览器的这个行为，并显示或隐藏一个视图层次结构。</p>
<p>如果路由器认为当前的应用状态需要某些特定的功能，而定义此功能的模块尚未加载，路由器就会按需<em>惰性加载</em>此模块。</p>
<p>路由器会根据你应用中的导航规则和数据状态来拦截 URL。 当用户点击按钮、选择下拉框或收到其它任何来源的输入时，你可以导航到一个新视图。 路由器会在浏览器的历史日志中记录这个动作，所以前进和后退按钮也能正常工作。</p>
<p>要定义导航规则，你就要把<em>导航路径</em>和你的组件关联起来。 路径（path）使用类似 URL 的语法来和程序数据整合在一起，就像模板语法会把你的视图和程序数据整合起来一样。 然后你就可以用程序逻辑来决定要显示或隐藏哪些视图，以根据你制定的访问规则对用户的输入做出响应。</p>
<h2 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h2><blockquote>
<p>Angular 应用是模块化的，它拥有自己的模块化系统，称作 <em>NgModule</em>。 一个 NgModule 就是一个容器，用于存放一些内聚的代码块，这些代码块专注于某个应用领域、某个工作流或一组紧密相关的功能。 它可以包含一些组件、服务提供者或其它代码文件，其作用域由包含它们的 NgModule 定义。 它还可以导入一些由其它模块中导出的功能，并导出一些指定的功能供其它 NgModule 使用。</p>
</blockquote>
<p>每个 Angular 应用都至少有一个 NgModule 类，也就是根模块，它习惯上命名为 <code>AppModule</code>，并位于一个名叫 <code>app.module.ts</code> 的文件中。<em>引导</em>这个根模块就可以启动你的应用。</p>
<h4 id="NgModule-metadata"><a href="#NgModule-metadata" class="headerlink" title="NgModule metadata"></a>NgModule metadata</h4><p>NgModule 是一个带有 <code>@NgModule()</code> 装饰器的类。<code>@NgModule()</code> 装饰器是一个函数，它接受一个元数据对象，该对象的属性用来描述这个模块。其中最重要的属性如下。</p>
<ul>
<li><code>declarations</code>（可声明对象表） —— 那些属于本 NgModule 的组件、<em>指令</em>、<em>管道</em>。</li>
<li><code>exports</code>（导出表） —— 那些能在其它模块的<em>组件模板</em>中使用的可声明对象的子集。</li>
<li><code>imports</code>（导入表） —— 那些导出了<em>本</em>模块中的组件模板所需的类的其它模块。</li>
<li><code>providers</code> —— 本模块向全局服务中贡献的那些服务的创建器。 这些服务能被本应用中的任何部分使用。（你也可以在组件级别指定服务提供者，这通常是首选方式。）</li>
<li><code>bootstrap</code> —— 应用的主视图，称为<em>根组件</em>。它是应用中所有其它视图的宿主。只有<em>根模块</em>才应该设置这个 <code>bootstrap</code> 属性。</li>
</ul>
<pre><code class="javascript">import &#123; NgModule &#125;      from &#39;@angular/core&#39;;
import &#123; BrowserModule &#125; from &#39;@angular/platform-browser&#39;;
@NgModule(&#123;
  imports:      [ BrowserModule ],
  providers:    [ Logger ],
  declarations: [ AppComponent ],
  exports:      [ AppComponent ],
  bootstrap:    [ AppComponent ]
&#125;)
export class AppModule &#123; &#125;</code></pre>
<h2 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h2><p><em>组件</em>控制屏幕上被称为视图的一小片区域。</p>
<p>比如，<code>HeroListComponent</code> 中有一个 名为 <code>heroes</code> 的属性，它储存着一个数组的英雄数据。 <code>HeroListComponent</code> 还有一个 <code>selectHero()</code> 方法，当用户从列表中选择一个英雄时，它会设置 <code>selectedHero</code> 属性的值。 该组件会从服务获取英雄列表，它是一个 TypeScript 的构造器参数型属性。本服务通过依赖注入系统提供给该组件。</p>
<pre><code class="javascript">export class HeroListComponent implements OnInit &#123;
  heroes: Hero[];
  selectedHero: Hero;

  constructor(private service: HeroService) &#123; &#125;

  ngOnInit() &#123;
    this.heroes = this.service.getHeroes();
  &#125;

  selectHero(hero: Hero) &#123; this.selectedHero = hero; &#125;
&#125;</code></pre>
<p>当用户在应用中穿行时，Angular 就会创建、更新、销毁一些组件。 你的应用可以通过一些可选的生命周期钩子比如 <code>ngOnInit()</code>）来在每个特定的时机采取行动。</p>
<h4 id="组件的元数据"><a href="#组件的元数据" class="headerlink" title="组件的元数据"></a>组件的元数据</h4><p><code>@Component</code> 装饰器会指出紧随其后的那个类是个组件类，并为其指定元数据。 在下面的范例代码中，你可以看到 <code>HeroListComponent</code> 只是一个普通类，完全没有 Angular 特有的标记或语法。 直到给它加上了 <code>@Component</code> 装饰器，它才变成了组件。</p>
<p>组件的元数据告诉 Angular 到哪里获取它需要的主要构造块，以创建和展示这个组件及其视图。 具体来说，它把一个<em>模板</em>（无论是直接内联在代码中还是引用的外部文件）和该组件关联起来。 该组件及其模板，共同描述了一个<em>视图</em>。</p>
<pre><code class="javascript">@Component(&#123;
  selector:    &#39;app-hero-list&#39;,
  templateUrl: &#39;./hero-list.component.html&#39;,
  providers:  [ HeroService ]
&#125;)
export class HeroListComponent implements OnInit &#123;
/* . . . */
&#125;</code></pre>
<p>这个例子展示了一些最常用的 <code>@Component</code> 配置选项：</p>
<ul>
<li><code>selector</code>：是一个 CSS 选择器，它会告诉 Angular，一旦在模板 HTML 中找到了这个选择器对应的标签，就创建并插入该组件的一个实例。 比如，如果应用的 HTML 中包含 <code>&lt;app-hero-list&gt;&lt;/app-hero-list&gt;</code>，Angular 就会在这些标签中插入一个 <code>HeroListComponent</code> 实例的视图。</li>
<li><code>templateUrl</code>：该组件的 HTML 模板文件相对于这个组件文件的地址。 另外，你还可以用 <code>template</code> 属性的值来提供内联的 HTML 模板。 这个模板定义了该组件的<em>宿主视图</em>。</li>
<li><code>providers</code>：当前组件所需的服务提供者的一个数组。在这个例子中，它告诉 Angular 该如何提供一个 <code>HeroService</code> 实例，以获取要显示的英雄列表。</li>
</ul>
<h4 id="模板与视图"><a href="#模板与视图" class="headerlink" title="模板与视图"></a>模板与视图</h4><p>你要通过组件的配套模板来定义其视图。模板就是一种 HTML，它会告诉 Angular 如何渲染该组件。</p>
<p>视图通常会分层次进行组织，让你能以 UI 分区或页面为单位进行修改、显示或隐藏。 与组件直接关联的模板会定义该组件的<em>宿主视图</em>。该组件还可以定义一个<em>带层次结构的视图</em>，它包含一些<em>内嵌的视图</em>作为其它组件</p>
<p><img src="https://angular.cn/generated/images/guide/architecture/component-tree.png" alt="Component tree"></p>
<h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><p> 你的模板可以使用<em>数据绑定</em>来协调应用和 DOM 中的数据，使用<em>管道</em>在显示出来之前对其进行转换，使用<em>指令</em>来把程序逻辑应用到要显示的内容上。</p>
<pre><code class="html">&lt;h2&gt;Hero List&lt;/h2&gt;

&lt;p&gt;&lt;i&gt;Pick a hero from the list&lt;/i&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li *ngFor=&quot;let hero of heroes&quot; (click)=&quot;selectHero(hero)&quot;&gt;
    &#123;&#123;hero.name&#125;&#125;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;app-hero-detail *ngIf=&quot;selectedHero&quot; [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</code></pre>
<p>这个模板使用了典型的 HTML 元素，比如 <code>&lt;h2&gt;</code> 和 <code>&lt;p&gt;</code>，还包括一些 Angular 的模板语法元素，如 <code>*ngFor</code>，<code>&#123;&#123;hero.name&#125;&#125;</code>，<code>click</code>、<code>[hero]</code> 和 <code>&lt;app-hero-detail&gt;</code>。这些模板语法元素告诉 Angular 该如何根据程序逻辑和数据在屏幕上渲染 HTML。</p>
<ul>
<li><code>*ngFor</code> 指令告诉 Angular 在一个列表上进行迭代。</li>
<li><code>&#123;&#123;hero.name&#125;&#125;</code>、<code>(click)</code> 和 <code>[hero]</code> 把程序数据绑定到及绑定回 DOM，以响应用户的输入。</li>
<li>模板中的 <code>&lt;app-hero-detail&gt;</code> 标签是一个代表新组件 <code>HeroDetailComponent</code> 的元素。 </li>
</ul>
<h6 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h6><p>Angular 支持<em>双向数据绑定</em>，这是一种对模板中的各个部件与组件中的各个部件进行协调的机制。 往模板 HTML 中添加绑定标记可以告诉 Angular 该如何连接它们。</p>
<p><img src="https://angular.cn/generated/images/guide/architecture/databinding.png" alt="Data Binding"></p>
<pre><code class="html">&lt;li&gt;&#123;&#123;hero.name&#125;&#125;&lt;/li&gt;
&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;
&lt;li (click)=&quot;selectHero(hero)&quot;&gt;&lt;/li&gt;
&lt;input [(ngModel)]=&quot;hero.name&quot;&gt;</code></pre>
<p>Angular 在每个 JavaScript 事件循环中处理<em>所有的</em>数据绑定，它会从组件树的根部开始，递归处理全部子组件。</p>
<h6 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h6><blockquote>
<p>Angular 的管道可以让你在模板中声明显示值的转换逻辑。 带有 <code>@Pipe</code> 装饰器的类中会定义一个转换函数，用来把输入值转换成供视图显示用的输出值。<code>&#123;&#123;interpolated_value | pipe_name&#125;&#125;</code></p>
</blockquote>
<p>Angular 自带了很多管道，比如 date 管道和 currency 管道，完整的列表参见 Pipes API 列表。你也可以自己定义一些新管道。</p>
<p>你可以把管道串联起来，把一个管道函数的输出送给另一个管道函数进行转换。 管道还能接收一些参数，来控制它该如何进行转换。比如，你可以把要使用的日期格式传给 <code>date</code> 管道：</p>
<pre><code class="html">&lt;!-- Default format: output &#39;Jun 15, 2015&#39;--&gt;

 &lt;p&gt;Today is &#123;&#123;today | date&#125;&#125;&lt;/p&gt;

&lt;!-- fullDate format: output &#39;Monday, June 15, 2015&#39;--&gt;

&lt;p&gt;The date is &#123;&#123;today | date:'fullDate'&#125;&#125;&lt;/p&gt;

 &lt;!-- shortTime format: output &#39;9:43 AM&#39;--&gt;

 &lt;p&gt;The time is &#123;&#123;today | date:'shortTime'&#125;&#125;&lt;/p&gt;</code></pre>
<h6 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h6><blockquote>
<p>Angular 的模板是<em>动态的</em>。当 Angular 渲染它们的时候，会根据<em>指令</em>给出的指示对 DOM 进行转换。 指令就是一个带有 <code>@Directive()</code> 装饰器的类。</p>
</blockquote>
<p>组件从技术角度上说就是一个指令，但是由于组件对 Angular 应用来说非常独特、非常重要，因此 Angular 专门定义了 <code>@Component()</code> 装饰器，它使用一些面向模板的特性扩展了 <code>@Directive()</code> 装饰器。</p>
<p>除组件外，还有两种指令：<em>结构型指令</em>和<em>属性型指令</em>。 Angular 本身定义了一系列这两种类型的指令，你也可以使用 <code>@Directive()</code> 装饰器来定义自己的指令。</p>
<p>像组件一样，指令的元数据把它所装饰的指令类和一个 <code>selector</code> 关联起来，<code>selector</code> 用来把该指令插入到 HTML 中。 在模板中，指令通常作为属性出现在元素标签上，可能仅仅作为名字出现，也可能作为赋值目标或绑定目标出现。</p>
<ul>
<li><p>结构型指令</p>
<p><em>结构型指令</em>通过添加、移除或替换 DOM 元素来修改布局。 这个范例模板使用了两个内置的结构型指令来为要渲染的视图添加程序逻辑：</p>
<pre><code class="html">&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;&lt;/li&gt;
&lt;app-hero-detail *ngIf=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</code></pre>
<ul>
<li>*ngFor是一个迭代器，它要求 Angular 为 <code>heroes</code> 列表中的每个英雄渲染出一个 <code>&lt;li&gt;</code>。</li>
<li>*ngIf<code>是个条件语句，只有当选中的英雄存在时，它才会包含 </code>HeroDetail` 组件。</li>
</ul>
</li>
<li><p>属性指令</p>
<p><em>属性型指令</em>会修改现有元素的外观或行为。 在模板中，它们看起来就像普通的 HTML 属性一样，因此得名“属性型指令”。</p>
<p><code>ngModel</code> 指令就是属性型指令的一个例子，它实现了双向数据绑定。 <code>ngModel</code> 修改现有元素（一般是 <code>&lt;input&gt;</code>）的行为：设置其显示属性值，并响应 change 事件。</p>
<pre><code class="html">&lt;input [(ngModel)]=&quot;hero.name&quot;&gt;</code></pre>
</li>
</ul>
<h2 id="服务与注入依赖"><a href="#服务与注入依赖" class="headerlink" title="服务与注入依赖"></a>服务与注入依赖</h2><blockquote>
<p><em>服务</em>是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。</p>
</blockquote>
<p>组件应该把诸如从服务器获取数据、验证用户输入或直接往控制台中写日志等工作委托给各种服务。通过把各种处理任务定义到可注入的服务类中，你可以让它被任何组件使用。 通过在不同的环境中注入同一种服务的不同提供者，你还可以让你的应用更具适应性。</p>
<h4 id="服务范例"><a href="#服务范例" class="headerlink" title="服务范例"></a>服务范例</h4><pre><code class="javascript">export class Logger &#123;
  log(msg: any)   &#123; console.log(msg); &#125;
  error(msg: any) &#123; console.error(msg); &#125;
  warn(msg: any)  &#123; console.warn(msg); &#125;
&#125;</code></pre>
<p>服务也可以依赖其它服务。比如，这里的 <code>HeroService</code> 就依赖于 <code>Logger</code> 服务，它还用 <code>BackendService</code> 来获取英雄数据。<code>BackendService</code> 还可能再转而依赖 <code>HttpClient</code> 服务来从服务器异步获取英雄列表。</p>
<pre><code class="javascript">export class HeroService &#123;
  private heroes: Hero[] = [];

  constructor(
    private backend: BackendService,
    private logger: Logger) &#123; &#125;

  getHeroes() &#123;
    this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; &#123;
      this.logger.log(`Fetched $&#123;heroes.length&#125; heroes.`);
      this.heroes.push(...heroes); // fill cache
    &#125;);
    return this.heroes;
  &#125;
&#125;</code></pre>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><blockquote>
<p>DI 被融入 Angular 框架中，用于在任何地方给新建的组件提供服务或所需的其它东西。 组件是服务的消费者，也就是说，你可以把一个服务<em>注入</em>到组件中，让组件类得以访问该服务类。</p>
</blockquote>
<p>在 Angular 中，要把一个类定义为服务，就要用 <code>@Injectable()</code> 装饰器来提供元数据，以便让 Angular 可以把它作为<em>依赖</em>注入到组件中。 同样，也要使用 <code>@Injectable()</code> 装饰器来表明一个组件或其它类（比如另一个服务、管道或 NgModule）<em>拥有</em>一个依赖。</p>
<ul>
<li><em>注入器</em>是主要的机制。Angular 会在启动过程中为你创建全应用级注入器以及所需的其它注入器。你不用自己创建注入器。</li>
<li>该注入器会创建依赖、维护一个<em>容器</em>来管理这些依赖，并尽可能复用它们。</li>
<li><em>提供者</em>是一个对象，用来告诉注入器应该如何获取或创建依赖。</li>
</ul>
<p>你的应用中所需的任何依赖，都必须使用该应用的注入器来注册一个提供者，以便注入器可以使用这个提供者来创建新实例。 对于服务，该提供者通常就是服务类本身。</p>
<p>当 Angular 创建组件类的新实例时，它会通过查看该组件类的构造函数，来决定该组件依赖哪些服务或其它依赖项。 比如 <code>HeroListComponent</code> 的构造函数中需要 <code>HeroService</code>：</p>
<pre><code class="javascript">constructor(private service: HeroService) &#123; &#125;</code></pre>
<p>当 Angular 发现某个组件依赖某个服务时，它会首先检查是否该注入器中已经有了那个服务的任何现有实例。如果所请求的服务尚不存在，注入器就会使用以前注册的服务提供者来制作一个，并把它加入注入器中，然后把该服务返回给 Angular。</p>
<h4 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h4><p>对于要用到的任何服务，你必须至少注册一个<em>提供者</em>。服务可以在自己的元数据中把自己注册为提供者，这样可以让自己随处可用。或者，你也可以为特定的模块或组件注册提供者。要注册提供者，就要在服务的 <code>@Injectable()</code> 装饰器中提供它的元数据，或者在 <code>@NgModule()</code> 或 <code>@Component()</code> 的元数据中。</p>
<ul>
<li><p>默认情况下，Angular CLI 的 <code>ng generate service</code> 命令会在 <code>@Injectable()</code> 装饰器中提供元数据来把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供者：</p>
<pre><code class="javascri">@Injectable(&#123;
  providedIn: &#39;root&#39;,
&#125;)</code></pre>
<p>当你在根一级提供服务时，Angular 会为 HeroService 创建一个单一的共享实例，并且把它注入到任何想要它的类中。这种在 <code>@Injectable</code> 元数据中注册提供者的方式还让 Angular 能够通过移除那些从未被用过的服务来优化大小。</p>
</li>
<li><p>当你使用特定的 NgModule 注册提供者时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 <code>@NgModule()</code> 装饰器中的 <code>providers</code> 属性：</p>
<pre><code class="javascript">@NgModule(&#123;
  providers: [
   BackendService,
   Logger
 ],
 ...
&#125;)</code></pre>
</li>
<li><p>当你在组件级注册提供者时，你会为该组件的每一个新实例提供该服务的一个新实例。 要在组件级注册，就要在 <code>@Component()</code> 元数据的 <code>providers</code> 属性中注册服务提供者。</p>
<pre><code class="javascript">@Component(&#123;
  selector:    &#39;app-hero-list&#39;,
  templateUrl: &#39;./hero-list.component.html&#39;,
  providers:  [ HeroService ]
&#125;)</code></pre>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>CreatorDP</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://ammydan.github.io/2020/10/13/Angular/">https://ammydan.github.io/2020/10/13/Angular/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2020 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/development/"># development</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/10/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84web%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/">前后端分离的web应用部署</a>
            
            
            <a class="next" rel="next" href="/2020/10/13/Express.js%E4%BD%BF%E7%94%A8/">Express.js使用</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© CreatorDP | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
